/**************************************************************************/
/*                                                                        */
/*                             ocp-lldb                                   */
/*                                                                        */
/*  Copyright 2012-2015, OCamlPro                                         */
/*                                                                        */
/*  All rights reserved.  See accompanying files for the terms under      */
/*  which this file is distributed. In doubt, contact us at               */
/*  contact@ocamlpro.com (http://www.ocamlpro.com/)                       */
/*                                                                        */
/**************************************************************************/

/* LLDB Objects are translated to either (1) finalized custom OCaml values (in which case the
   destructor is called on GC collection) or (2) abstract OCaml values (in which case, the
   destructor is not called). Val_final() is used to create finalized values, while Val_abstract()
   is used for the second kind.
*/

#include "lldbOCaml.h"

#include <stdio.h>

/* All these functions must be accessible from code generated by "ocamlopt".
Since "ocamlopt" uses C conventions, they must all be declared here, otherwise
you will get an "undefined reference" to then when linking.
*/
extern "C"
{
  void* lldbOCaml_cast(int dest_id, int src_id, void* ptr);
  void* Abstract_val(const int class_id, value v);
  value Val_abstract(const int class_id, const void* ptr);
  value Val_final(const int class_id, const void* ptr);
  value LLDBOCaml_Delete_ml(value v);
  void LLDBOCaml_Error(int errcode);
  void* OCPLLDB_val(const int dest_id, value v);
  value lldb_is_NULL(value v);
  
  value lldb_fopen_ml(value filename_v, value mode_v);
  value lldb_fclose_ml(value file_v);
  value lldb_fflush_ml(value file_v);

  
  /* SBDebugger static methods */
  value SBDebugger_Initialize_ml(value unit_v);
  value SBDebugger_Terminate_ml(value unit_v);  
  value SBDebugger_Test_ml(value unit_v);
  value SBDebugger_Create_ml(value bool_v);
  value SBDebugger_Destroy_ml(value debugger_v);  

  /* Manually written stubs */
  value SBModule_GetVersion_ml(value self_v, value versions_v);  
  value SBTarget_LaunchVerySimple_ml(value target_v, value argv_v,
                                     value working_directory_v);
  value SBCommandInterpreter_AddCommand_ml(value interp_v, value name_v,
                                           value callback_v, value help_v);
  value SBBreakpoint_SetCallback_ml(value self_v, value callback_v);
  value SBFileSpec_new_CreateByName_ml(value path_v, value resolve_v);
}

#include "lldbIncludes_ml.h"

using namespace lldb;

/* Each class that we use must have an identifier, so that we can cast correctly
between classes, and check from time to time that we are manipulating
the correct class. For each class, you must define 3 macros, and modify the 
[lldb_object_finalize] function. */

#include "lldbClasses_ml.h"

  void LLDBOCaml_Error(int errcode){
    fprintf(stderr, "LLDBOCaml_Error: exiting with code %d\n", errcode);
    exit(errcode);
  }
  
void lldb_object_finalize(value v)
{
  int class_id = Field(v,1);
  void* ptr = (void*) Field(v,2);
  if( ptr != NULL ){
    switch(class_id){
#include "lldbDelete_ml.h"
    default: LLDBOCaml_Error(5);
    }
    Field(v,2) = (value)NULL;
  }
}

static struct custom_operations lldb_object_ops = {
  (char*)"com.ocamlpro.lldb",
  lldb_object_finalize,
  custom_compare_default,
  custom_hash_default,
  custom_serialize_default,
  custom_deserialize_default
};


void* OCPLLDB_val(const int dest_id, value v)
{
  //    fprintf(stderr, "OCPLLDB_val(%d, %ld, %lX)\n",
  //	    class_id, Field(v, 0), (void*)Field(v, 1));	    
  int src_id = Field(v,1);
  void* ptr = (void*) Field(v,2);
  return lldbOCaml_cast(dest_id, src_id, ptr);
}

value Val_final(const int class_id, const void* ptr)
{
  value v = caml_alloc_custom(&lldb_object_ops, 2*sizeof(value), 0, 1);
  Field(v, 1) = class_id;
  Field(v, 2) = (value)ptr;
  //  fprintf(stderr, "Val_OCPLLDB(%d, %lX)\n", wxClassID, ptr);
  return v;
}

value Val_abstract(const int class_id, const void* ptr)
{
  value v = caml_alloc(3, Abstract_tag);
  Field(v, 0) = 0; /* useless */
  Field(v, 1) = class_id;
  Field(v, 2) = (value)ptr;
  //  fprintf(stderr, "Val_OCPLLDB(%d, %lX)\n", wxClassID, ptr);
  return v;
}

value lldb_is_NULL(value v)
{
  void* ptr = (void*) Field(v,2);
  return Val_bool( ptr == NULL );
}

/* This function is used when we want to cast an object from one LLDB
   class to another one. */
void* lldbOCaml_cast(int dest_id, int src_id, void* ptr)
{
  if( dest_id == src_id) return ptr;
  if( ptr == NULL) return ptr;
  fprintf(stderr, "Error: asking for %d, received %d\n", dest_id, src_id);
  LLDBOCaml_Error(2);
  return NULL;
}

value LLDBOCaml_Delete_ml(value v)
{
  lldb_object_finalize(v);
  return Val_unit;
}

/**************************************************************************/
/*                                                                        */
/*                                                                        */
/*              Stubs for static methods                                  */
/*                                                                        */
/*                                                                        */
/**************************************************************************/

value SBDebugger_Initialize_ml(value unit_v)
{
  SBDebugger::Initialize();
  SBHostOS::ThreadCreated ("<lldb.driver.main-thread>");
  return Val_unit;
}

value SBDebugger_Terminate_ml(value unit_v)
{
  SBDebugger::Terminate();
  return Val_unit;
}

value SBDebugger_Create_ml(value bool_v)
{
  bool boolx = bool_v == Val_true ? true : false;
  SBDebugger *m_debugger = new SBDebugger(SBDebugger::Create(boolx));
  return Val_SBDebugger(m_debugger);
}


/**************************************************************************/
/*                                                                        */
/*                                                                        */
/*              Stubs to manipulate FILE* values                          */
/*                                                                        */
/*                                                                        */
/**************************************************************************/

value lldb_fopen_ml(value filename_v, value mode_v)
{
  FILE *file = fopen(String_val(filename_v), String_val(mode_v));
  return Val_abstract(0, file);
}

value lldb_fclose_ml(value file_v)
{
  FILE* fp = (FILE*)OCPLLDB_val(0, file_v);
  if( fp != NULL) fclose(fp);
  Field(file_v,2) = (value)NULL;
  return Val_unit;
}

value lldb_fflush_ml(value file_v)
{
  FILE* fp = (FILE*)OCPLLDB_val(0, file_v);
  if( fp != NULL) fflush(fp);
  return Val_unit;
}

char **StringsOption_val(value strings_v)
{
  if(strings_v == Val_int(0)) return NULL;
  value v = Field(strings_v, 0);
  size_t size = Wosize_val(v);
  char** tab = (char**)malloc( sizeof(char*) * (size+1));
  for(int i=0; i<size; i++) tab[i] = String_val(Field(v,i));
  tab[size] = NULL;
  return tab;
}

char *StringOption_val(value stringo_v)
{
  if(stringo_v == Val_int(0)) return NULL;
  return String_val(Field(stringo_v, 0));
}

/**************************************************************************/
/*                                                                        */
/*                                                                        */
/*              Stubs that cannot be automatically generated              */
/*                                                                        */
/*                                                                        */
/**************************************************************************/



value SBTarget_LaunchVerySimple_ml(value target_v, value argv_v, value working_directory_v)
{
  int nargs = Wosize_val(argv_v);
  fprintf(stderr, "nargs = %d\n", nargs);
  const char* argv[nargs+1];
  int i;
  for(i = 0; i < nargs; i++ ) argv[i] = String_val( Field(argv_v, i));
  argv[nargs] = NULL;
  SBProcess* m_process = new SBProcess();
  SBTarget* m_target = SBTarget_val( target_v );
  *m_process = m_target->LaunchSimple( argv, NULL, String_val(working_directory_v));
  return Val_SBProcess(m_process);
}
/* SBProcess 	LaunchSimple (const char **argv, const char **envp, const char *working_directory) */

value SBDebugger_Destroy_ml(value debugger_v)
{
  SBDebugger* m_debugger = SBDebugger_val(debugger_v);
  SBDebugger::Destroy (*m_debugger);
  return Val_unit;
}

class OCamlCommand : public SBCommandPluginInterface
{
  value command_v;
public:
  virtual bool 
  DoExecute (lldb::SBDebugger debugger,
             char** command,
             lldb::SBCommandReturnObject &result)
  {
    CAMLparam0();
    CAMLlocal1(args_v);
    int nargs = 0;
    int i;
    if( command ){
      char** s = command;
      while(*s != NULL){ nargs++; s++; }
    }
    args_v = caml_alloc(nargs, 0);
    for(i=0; i< nargs; i++) Field(args_v,i) = Val_unit;
    for(i=0; i< nargs; i++){
      caml_modify(& Field(args_v,i), caml_copy_string(command[i]));
    }
    caml_callback(command_v, args_v);
    CAMLreturn(false);
  }
  OCamlCommand(value callback_v){
    command_v = callback_v;
    caml_register_global_root(&command_v);
  }
  ~OCamlCommand(){
    command_v = Val_unit;
    caml_remove_global_root(&command_v);
  }
};

value SBCommandInterpreter_AddCommand_ml(value interp_v, value name_v, value callback_v, value help_v)
{
  SBCommandInterpreter* interp = SBCommandInterpreter_val(interp_v);
  interp->AddCommand( String_val(name_v), new OCamlCommand( callback_v ), String_val(help_v));
  return Val_unit;
}


value SBModule_GetVersion_ml(value self_v, value versions_v){
  SBModule* self = SBModule_val(self_v);
  // arg1 ("versions") Ident "uint32_t" Kwd "*"
  uint32_t* versions = (uint32_t*)versions_v;
  // arg2 ("num_versions") Ident "uint32_t" 
  uint32_t num_versions = Wosize_val(versions_v);
  uint32_t ret = self->GetVersion(versions, num_versions);
  for(int i=num_versions; i>0; i--){
    Field(versions_v, i-1) = Int_val(versions[i-1]);
  }
  return Val_long(ret);
  // reply: Ident "uint32_t" 
}


bool BreakpointHitCallback_ml(value* ptr,
                              SBProcess &process,
                              SBThread &thread,
                              lldb::SBBreakpointLocation &location)
{
  CAMLparam0();
  CAMLlocal3(process_v, thread_v, location_v);
  process_v = Val_SBProcess(&process);
  thread_v = Val_SBThread(&thread);
  location_v = Val_SBBreakpointLocation(&location);
  value ret = caml_callback3(*ptr, process_v, thread_v, location_v);
  CAMLreturn(ret == Val_true ? true : false);
}

value SBBreakpoint_SetCallback_ml(value self_v, value callback_v){
  SBBreakpoint* self = SBBreakpoint_val(self_v);
  // arg1 ("callback") Ident "BreakpointHitCallback" 
  /* arg type not implemented */
  // arg2 ("baton") Ident "void" Kwd "*" 
  /* arg type not implemented */
  value* ptr = (value*)malloc(sizeof(value*));
  *ptr = callback_v;
  caml_register_global_root(ptr);
  self->SetCallback((lldb::SBBreakpoint::BreakpointHitCallback)BreakpointHitCallback_ml,
                    (void*)ptr);
  return Val_unit;
  // reply: Ident "void" 
}

value SBDebugger_GetSourceManager_ml(value self_v){
  SBDebugger* self = SBDebugger_val(self_v);
  if( self == NULL ) caml_failwith("SBDebugger_GetSourceManager_ml: self is NULL");
  SBSourceManager* ret = (SBSourceManager*)malloc(sizeof(SBSourceManager));
  *ret = self->GetSourceManager();
  return Val_SBSourceManager(ret);
}

value SBFileSpec_new_CreateByName_ml(value path_v, value resolve_v)
{
  char *path = String_val(path_v);
  bool resolve = resolve_v == Val_true ? true : false;
  return Val_SBFileSpec(new SBFileSpec(path, resolve));
}

/**************************************************************************/
/*                                                                        */
/*                                                                        */
/*              Simple test function                                      */
/*                                                                        */
/*                                                                        */
/**************************************************************************/

value SBDebugger_Test_ml(value unit_v)
{
  SBDebugger* m_debugger = new SBDebugger(SBDebugger::Create(false));
  SBCommandReturnObject command_result;      
  bool handle_events = true;
  bool spawn_thread = false;
  SBTarget* m_target = new SBTarget();
  *m_target = m_debugger->CreateTarget ("/home/lefessan/.opam/4.01.0/bin/ocamlopt.opt");
  SBCommandInterpreter* m_interp = new SBCommandInterpreter();
  *m_interp = m_debugger->GetCommandInterpreter();
  m_interp->HandleCommand ("break set -n main", command_result);
  m_interp->HandleCommand ("run", command_result);
  m_debugger->RunCommandInterpreter(handle_events, spawn_thread);
  SBDebugger::Destroy (*m_debugger);
  return Val_unit;
}

/**************************************************************************/
/*                                                                        */
/*                                                                        */
/*              Include automatically generated stubs                     */
/*                                                                        */
/*                                                                        */
/**************************************************************************/

#include "lldbClasses_ml.h"

#include "lldbGenerated_ml.h"

